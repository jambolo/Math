/** @file *//********************************************************************************************************

                                                     Vector3d.inl

						                    Copyright 2003, John J. Bolton
	--------------------------------------------------------------------------------------------------------------

	$Header: //depot/Libraries/Math/Vector3d.inl#8 $

	$NoKeywords: $

 ********************************************************************************************************************/

#pragma once


#include "Vector3d.h"

#include "Math.h"

#include <cassert>
#include <cmath>


/********************************************************************************************************************/
/*																													*/
/********************************************************************************************************************/

inline Vector3d::Vector3d( double x, double y, double z )
	: m_X( x ), m_Y( y ), m_Z( z )
{
}


/********************************************************************************************************************/
/*																													*/
/********************************************************************************************************************/

inline Vector3d::Vector3d( double const v[ 3 ] )
	: m_X( v[ 0 ] ), m_Y( v[ 1 ] ), m_Z( v[ 2 ] )
{
}


/********************************************************************************************************************/
/*																													*/
/********************************************************************************************************************/

inline double Vector3d::Length2() const
{
	return ( m_X * m_X + m_Y * m_Y + m_Z * m_Z ); 
}


/********************************************************************************************************************/
/*																													*/
/********************************************************************************************************************/

inline double Vector3d::Length() const
{
	return sqrt( Length2() ); 
}


/********************************************************************************************************************/
/*																													*/
/********************************************************************************************************************/

inline double Vector3d::ILength() const
{
	double const	len	= Length();

	assert( !Math::IsCloseToZero( len, Math::DEFAULT_DOUBLE_TOLERANCE ) );

	if ( !Math::IsCloseToZero( len, Math::DEFAULT_DOUBLE_TOLERANCE ) )
	{
		return 1.0 / len;
	}
	else
	{
		return 1.0;
	} 
}


/********************************************************************************************************************/
/*																													*/
/********************************************************************************************************************/

inline double Vector3d::ILength2() const
{
	double const	len2	= Length2();

	assert( !Math::IsCloseToZero( len2, 2.0*Math::DEFAULT_DOUBLE_TOLERANCE ) );

	if ( !Math::IsCloseToZero( len2, 2.0*Math::DEFAULT_DOUBLE_TOLERANCE ) )
	{
		return 1.0 / len2;
	}
	else
	{
		return 1.0;
	} 
}


/********************************************************************************************************************/
/*																													*/
/********************************************************************************************************************/

inline bool Vector3d::IsNormalized() const
{
	return ( Math::IsCloseTo( Length2(), 1., 2.*Math::DEFAULT_DOUBLE_NORMALIZED_TOLERANCE ) );
}


/********************************************************************************************************************/
/*																													*/
/********************************************************************************************************************/

inline Vector3d const & Vector3d::Negate()
{
	m_X = -m_X;
	m_Y = -m_Y;
	m_Z = -m_Z;

	return *this;
}


/********************************************************************************************************************/
/*																													*/
/********************************************************************************************************************/

inline Vector3d const & Vector3d::Normalize()
{
	return Scale( ILength() );
}


/********************************************************************************************************************/
/*																													*/
/********************************************************************************************************************/

inline Vector3d const & Vector3d::Add( Vector3d const & b )
{
	m_X += b.m_X;
	m_Y += b.m_Y;
	m_Z += b.m_Z;

	return *this;
}


/********************************************************************************************************************/
/*																													*/
/********************************************************************************************************************/

inline Vector3d const & Vector3d::Subtract( Vector3d const & b )
{
	m_X -= b.m_X;
	m_Y -= b.m_Y;
	m_Z -= b.m_Z;

	return *this;
}


/********************************************************************************************************************/
/*																													*/
/********************************************************************************************************************/

inline Vector3d const & Vector3d::Scale( double scale )
{
	m_X *= scale;
	m_Y *= scale;
	m_Z *= scale;

	return *this;
}


/********************************************************************************************************************/
/*																													*/
/********************************************************************************************************************/

inline Vector3d const & Vector3d::operator +=( Vector3d const & b )
{
	return Add( b );
}


/********************************************************************************************************************/
/*																													*/
/********************************************************************************************************************/

inline Vector3d const & Vector3d::operator -=( Vector3d const & b )
{
	return Subtract( b );
}


/********************************************************************************************************************/
/*																													*/
/********************************************************************************************************************/

inline Vector3d const & Vector3d::operator *=( double scale )
{
	return Scale( scale );
}


/********************************************************************************************************************/
/*																													*/
/********************************************************************************************************************/

inline Vector3d const &	Vector3d::operator *=( Matrix33d const & m )
{
	return Transform( m );
}


/********************************************************************************************************************/
/*																													*/
/********************************************************************************************************************/

//!
//! @note	In order to multiply, a 4th element with the value of 1 is implicit.

inline Vector3d const &	Vector3d::operator *=( Matrix43d const & m )
{
	return Transform( m );
}


/********************************************************************************************************************/
/*																													*/
/********************************************************************************************************************/

inline Vector3d Vector3d::operator -() const
{
	return Vector3d( *this ).Negate();
}


/********************************************************************************************************************/
/*																													*/
/********************************************************************************************************************/

inline Vector3d Vector3d::Origin()
{
	return Vector3d( 0.0, 0.0, 0.0 );
}


/********************************************************************************************************************/
/*																													*/
/********************************************************************************************************************/

inline Vector3d Vector3d::XAxis()
{
	return Vector3d( 1.0, 0.0, 0.0 );
}


/********************************************************************************************************************/
/*																													*/
/********************************************************************************************************************/

inline Vector3d Vector3d::YAxis()
{
	return Vector3d( 0.0, 1.0, 0.0 );
}


/********************************************************************************************************************/
/*																													*/
/********************************************************************************************************************/

inline Vector3d Vector3d::ZAxis()
{
	return Vector3d( 0.0, 0.0, 1.0 );
}


/********************************************************************************************************************/
/*																													*/
/********************************************************************************************************************/

inline Vector3d operator +( Vector3d const & a, Vector3d const & b )
{
	return Vector3d( a ).Add( b );
}


/********************************************************************************************************************/
/*																													*/
/********************************************************************************************************************/

inline Vector3d operator -( Vector3d const & a, Vector3d const & b )
{
	return Vector3d( a ).Subtract( b );
}


/********************************************************************************************************************/
/*																													*/
/********************************************************************************************************************/

//! @note	When multiplying a vector and a matrix, the operator is commutative since the order of the operands is
//!			only notational.

inline Vector3d operator *( Vector3d const & v, Matrix33d const & m )
{
	return Vector3d( v ).Transform( m );
}


/********************************************************************************************************************/
/*																													*/
/********************************************************************************************************************/

//! @note	When multiplying a vector and a matrix, the operator is commutative since the order of the operands is
//!			only notational.

inline Vector3d operator *( Matrix33d const & m, Vector3d const & v )
{
	return Vector3d( v ).Transform( m );
}


/********************************************************************************************************************/
/*																													*/
/********************************************************************************************************************/

//! @note	When multiplying a vector and a matrix, the operator is commutative since the order of the operands is
//!			only notational.
//! @note	In order to multiply, a 4th element with the value of 1 is implicit.

inline Vector3d operator *( Vector3d const & v, Matrix43d const & m )
{
	return Vector3d( v ).Transform( m );
}


/********************************************************************************************************************/
/*																													*/
/********************************************************************************************************************/

//! @note	When multiplying a vector and a matrix, the operator is commutative since the order of the operands is
//!			only notational.
//! @note	In order to multiply, a 4th element with the value of 1 is implicit.

inline Vector3d operator *( Matrix43d const & m, Vector3d const & v )
{
	return Vector3d( v ).Transform( m );
}


/********************************************************************************************************************/
/*																													*/
/********************************************************************************************************************/

inline double Dot( Vector3d const & a, Vector3d const & b )
{
	return ( a.m_X * b.m_X + a.m_Y * b.m_Y + a.m_Z * b.m_Z );
}


/********************************************************************************************************************/
/*																													*/
/********************************************************************************************************************/

inline Vector3d Cross( Vector3d const & a, Vector3d const & b )
{
	return Vector3d( a.m_Y * b.m_Z - a.m_Z * b.m_Y,
					 a.m_Z * b.m_X - a.m_X * b.m_Z,
					 a.m_X * b.m_Y - a.m_Y * b.m_X );
}


/********************************************************************************************************************/
/*																													*/
/********************************************************************************************************************/

//! @note	When multiplying a vector and a scalar, the operator is commutative since the order of the operands is
//!			only notational.

inline Vector3d operator *( Vector3d const & v, double s )
{
	return Vector3d( v ).Scale( s );
}


/********************************************************************************************************************/
/*																													*/
/********************************************************************************************************************/

//! @note	When multiplying a vector and a scalar, the operator is commutative since the order of the operands is
//!			only notational.

inline Vector3d operator *( double s, Vector3d const & v )
{
	return Vector3d( v ).Scale( s );
}
